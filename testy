#!/bin/bash
#
# parse the test file into an array of text for each test first before
# commencing with other processing

read -r -d '' usage <<EOF
usage:    testy <testfile.org> [test# test# ...]
          testy --help

examples: testy test_prob1.org        # runs all tests in file
          testy test_prob1.org 3 5 7  # runs tests 3,5,7 in file
          SHOW=1 test_prob1.org       # runs tests and prints all failures to stdout

Run tests for a shell program specified in an org-like file and report
the results.

--- INPUT FORMAT ---

Tests are specified in org-like files. Each top-level section starts
with a * with a test title, followed by comments and test sessions of
input/output. Each test can have multiple sessions. As a session is
found it is run. If the session fails, subsequent sessions for that
test are not run.

Sample input:
================
#+TITLE: Sample Tests

* Test echo
Check that the 'echo' command in bash is working.

The 'sh' is not honored in testy; it is for easy editing in Emacs.

#+BEGIN_SRC sh
>> echo 'hello'
hello
>> echo 'Hi there!'
Hi there!
#+END_SRC

* Test printf
Tests whether printf works.

#+BEGIN_SRC sh
>> printf "Hello world\n"
Hello world
>> printf "Multi-line\noutput is expected\nhere\n"
Multi-line
output is expected
here
>> printf "%s\n" "substitute me"
substitute me
#+END_SRC

This second session below will fail and record the results of the
failure in a file.
#+BEGIN_SRC sh
>> echo 'hi'
hi
>> printf 'INTENTIONAL fail\n'
INTENTIONALly fails
#+END_SRC

* Test bc
This test uses a different interpreter than the standard 'bash'. The
'bc' program interprets standard mathematical expressions. Note the
use of #+TESTY expression to change the program for this test.

#+TESTY: program="bc -iq"
#+BEGIN_SRC sh
>> 1+1
2
>> 3*5+12
27
#+END_SRC
================

--- BEHAVIOR / ENVIRONMENT VARIABLES ---
The following variables can be specified in test files via lines like
  #+TESTY: var="value"
or on via an environment variable during a program run as in
  > VAR="value" testy testfile.org

They will change the behavior of how the test data is interpretted.

Global variables that are usually specified at the beginning of a test
file before any other tests.
PROGRAM="bash"           : program to run/test if no option is specified
PROMPT=">>               : prompt to honor if none is specified
ECHOING="input"          : {input, both} for program input echoing style
TAG="testy"              : prefix for output files
RESULTDIR="test-results" : directory where the resutls will be written

Local variables that can be specified for a single test session in an
individual test.
program="bash"           : override PROGRAM for an individual test session
prompt=">>"              : override PROMPT for an individual test session
echoing="input"          : override ECHOING for an individual test session
tag="testy"              : override TAG for an individual test session
resultdir="test-results" : override RESULTDIR for an individual test session

These variables control some global behavior of the testy.
SHOW=0            : set to 1 to print test error results after completing
DEBUG=0           : set to 1 to print LOTS of debugging messages
EOF


# some global options/programs
STDBUF="stdbuf -i 0 -o 0 -e 0"                      # disables standard IO buffering for a program
SDIFF="diff -ytbB"                                  # side by side diff, no tabs, ignore space changes, ignore blank lines
DIFF="diff -bB \
           --unchanged-line-format='' \
           --old-line-format='EXPECT:%4dn) %L' \
           --new-line-format='ACTUAL:%4dn) %L'"      # diff which will show prepend EXPECT/ACTUAL to differing lines
TIMEOUTCMD="timeout --signal KILL"                   # kills user programs after a certain duration  of 'timeout'  
TIMEOUT="10s"                                        # time after which to kill a test, passed to 'timeout' command
VALG_ERROR="13"                                      # error code that valgrind should return on detecting errors

VALGRIND_PROG="valgrind --leak-check=full --show-leak-kinds=all --error-exitcode=13"

# default values for the program to be tested
PROGRAM=${PROGRAM:-"bash -v"}                                   # program to run if no option is specified
PROMPT=${PROMPT:-">>"}                                         # prompt to honor if none is specified
ECHOING=${ECHOING:-"input"}                                  # {input, both} for program input echoing style
TAG="testy"                                         # prefix for the files that are produced by testy
RESULTDIR="test-results"                              # directory where the resutls will be written
USE_VALGRIND="0"

# default values for where the results will be stored
test_title_width=20                                      # initial width for test test_titles, set to widest during initial parsing

function reset_options(){                           # reset options to defaults, run before each test session
    program=$PROGRAM
    prompt=$PROMPT
    echoing=$ECHOING
    tag=$TAG
    timeout=$TIMEOUT                                # time after which to kill a test, passed to 'timeout' command
    resultdir=$RESULTDIR
    use_valgrind=0
}    


function debug(){                                   # print a debug message
    if [[ ! -z "$DEBUG" ]]; then
        echo "==DBG== $1" > /dev/stderr
    fi
}

function updateline(){                              # processes $line to set some other global variables
    line="$REPLY"                                   # copy from REPLY to avoid losing whitespace
    ((linenum++))                                   # update the current line number 
    prefix="${line%% *}"                            # extracts the first word on the line as prefix
    suffix="${line#* }"                             # extracts remainder of line
}    


debug "PROGRAM is $PROGRAM"

################################################################################
# Run a Test Session
#
# Sets up a test session which is denoted by the #+BEGIN_SRC/#+END_SRC
# tags in the input file. Will set the 'status' variable before
# exiting to indicate whether the test passes or fails. Influenced by
# many of the run variables including
# - program
# - tag
# - prompt
# 
# The function is run in a context where 'read' will extract lines
# from the test session.
function run_test_session(){

    mkdir -p $resultdir                               # set up test results directory
    actual_file=$(printf "%s/%s-%02d-actual.tmp" "$resultdir" "$tag" "$testnum")
    expect_file=$(printf "%s/%s-%02d-expect.tmp" "$resultdir" "$tag" "$testnum")
    result_file=$(printf "%s/%s-%02d-result.tmp" "$resultdir" "$tag" "$testnum")
    valgrd_file=$(printf "%s/%s-%02d-valgrd.tmp" "$resultdir" "$tag" "$testnum")
    rm -f ${actual_file} ${expect_file} ${result_file} ${valgrd_file}

    if [[ "$use_valgrind" = 1 ]]; then
        VALGRIND="${VALGRIND_PROG} --log-file=${valgrd_file}"
    else
        VALGRIND=""
    fi

    toprog_fifo=$(mktemp --tmpdir testy_to.XXXXXX)  # set up communication with the program being tested
    fromprog_file=$(mktemp --tmpdir testy_from.XXXXXX)
    debug "toprog_fifo: $toprog_fifo"
    debug "fromprog_fifo: $fromprog_fifo"
    rm -f ${toprog_fifo} ${fromprog_file}           # remove just in case

    mkfifo $toprog_fifo                             # create the fifos
    # mkfifo $fromprog_fifo

    # RUN THE PROGRAM
    #
    # - timeout will kill the program after a certain duration
    # - stdbuf disables buffering and prevents stalled output problems
    # - valgrind may be turned on to check for memory errors
    # - input is read from a fifo from the specfile
    # - output is directed to a file
    debug "running: '$TIMEOUTCMD $timeout $STDBUF $VALGRIND $program <${toprog_fifo} &> ${fromprog_file} &'"
    $TIMEOUTCMD $timeout $STDBUF $VALGRIND $program <${toprog_fifo} &> ${fromprog_file} &
    pid=$!
    debug "child pid: $pid"

    # open to after running the program or testy will stall 
    exec {to}>${toprog_fifo}                        # open connection to fifo for writing
    # exec {from}<${fromprog_fifo}                    # and for reading

    debug "to fd: $to"
    # debug "from fd: $from"

    status="pass"                                   # initial status, change to 'FAIL' if things go wrong
    fail_messages=()
    all_input=()

    session_beg_line=$((linenum+1))
    # MAIN LOOP to read lines of input, feed program, check output
    while read -r; do                                    # read a line from the test session
        updateline
        debug "$linenum: $line"
        
        case "$prefix" in
            "#+END_SRC")                              # end of test, break out
                debug "^^ end of testing session"
                break
                ;;
            "$prompt")                                # test input, feed to program
                input="$suffix"
                all_input+=("$input")                 # append to all_input array for later processing
                debug "^^ sending input"
                printf "%s\n" "$input" >&$to          # send input after prompt to program, printf in this way preserves embedded newlines
                ;;
            *)                                        # other lines are test output
                debug "^^ expected output"
                ;;
        esac                                          # DONE with test input, either pass or fail
    done;
    session_end_line=$((linenum-1))

    debug "session lines: beg $session_beg_line end $session_end_line"

    debug "closing to fifo fd ${to}"
    exec {to}>&-                                      # closes to fifo

    debug "waiting on finished child"                 
    wait $pid &> /dev/null                            # wait on the child to finish
    retcode="$?"
    debug "wait returned: $retcode"                 # may want to add checks here for return code of child

    case "$retcode" in
        "$VALG_ERROR")
            status="FAIL"
            fail_messages+=("FAILURE($retcode): Valgrind detected errors")
            ;;
        137)
            status="FAIL"
            fail_messages+=("FAILURE($retcode) due to TIMEOUT: Runtime exceeded maximum of '$timeout'")
            ;;
        139)
            status="FAIL"
            fail_messages+=("FAILURE($retcode) due to Kill Signal from OS: likely a SEGFAULT occured")
            ;;
    esac        

    # ADDING IN PROMPTS TO ECHOED INPUT
    # NOTE: The code below handles adding prompts to input lines that
    # are echoed without it.  Originally was trying to do this with
    # sed or awk but the quoting becomes a huge mess: any input lines
    # with special characters like $ or " need to be escaped leading
    # to huge headaches.  The shell string equality = operator is
    # actually cleaner here.  The below uses the shell
    # directly. Output is redirected to an open FD to prevent needing
    # constantly re-open the file for appending (could alternatively
    # do this with { } construct).  This approach can be fooled: if an
    # output line matches an input line, the prompt may be added at
    # the wrong spot.
    if [[ "$ECHOING" = "input" ]]; then            # program may only echo input necessitating adding prompts to output
        idx=0                                         # index for input line
        exec {mod}>${fromprog_file}.mod
        while read -r; do                             # read from output file into default REPLY var
            if (( idx < ${#all_input[@]} )) &&        # still in bounds for input lines
               [[ "${all_input[idx]}" = "$REPLY" ]];  # input line matches the program output
            then
                REPLY="$prompt $REPLY";               # add the prompt to this line
                ((idx++))                             # move to the next input to look for
                debug "added prompt to input $idx: $REPLY"
            fi;
            printf '%s\n' "$REPLY" >&$mod             # output the (un)modified line into the modified file
        done < ${fromprog_file}                       # reading from the original output file
        exec {mod}>&-                                 # close the modified file
        mv ${fromprog_file}.mod ${fromprog_file}      # copy modified file back to original
    fi

    # printf "$expect\n" > ${expect_file}
    # printf "$actual\n" > ${actual_file}
    sed -n "${session_beg_line},${session_end_line}p" $specfile > ${expect_file}
    cp ${fromprog_file} ${actual_file}

    actual_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' $actual_file)
    expect_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' $expect_file)
    # total_width=$((actual_width + expect_width + 3))
    col_width=$((actual_width > expect_width ? actual_width : expect_width))
    total_width=$((col_width*2 + 3))
    debug "actual_width $actual_width"
    debug "expect_width $expect_width"
    debug "col_width $col_width"
    debug "total_width $total_width"
    
    diffcmd="$DIFF ${expect_file} ${actual_file}"
    diffresult=$(eval "$diffcmd")
    diffreturn="$?"
    debug "diffresult: $diffresult"
    debug "diffreturn: $diffreturn"
    if [[ "$diffreturn" != "0" ]]; then
        status="FAIL"
        fail_messages+=("FAILURE: Output Mismatch at lines marked")
    fi

    if [[ "$status" = "pass" ]]; then                      # test failed
        debug "NORMAL cleanup"                          # normal finish
        debug "Checking child status with kill -0"
        kill -0 $pid  >& /dev/null
        debug "kill returned: $?"
    else
        debug "FAILURE cleanup"
        {  printf '(TEST %d) %s\n' "$testnum" "$test_title"
           printf 'COMMENTS:\n'
           printf "${comments}\n" 
           printf 'program: %s\n' "$program"
           printf "Failure messages:\n"
           for msg in "${fail_messages[@]}"; do
               printf "%s\n" "- $msg"
           done

           printf "\n"

           if [[ "$diffreturn" != "0" ]]; then      # show differences between expect and actual
               printf "%s\n" "--- Side by Side Differences ---"
               printf "%s\n" "- Expect output in: $expect_file" 
               printf "%s\n" "- Acutal output in: $actual_file" 
               printf "%s\n" "- Differing lines have a character like '|' in the middle\n"
               printf "%-${col_width}s   %-${col_width}s\n" "==== EXPECT ====" "==== ACTUAL ===="
               $SDIFF -W $total_width $expect_file $actual_file 
               printf "%s\n" "--- Line Differences ---"
               printf "%s\n" "$diffresult"
               printf "\n"
           fi

           if [[ "$use_valgrind" = "1" ]]; then     # show valgrind log
               printf "%s\n" "--- Valgrind Log from: $valgrd_file ---"
               cat $valgrd_file
               printf "\n"
           fi
        } &> ${result_file}

        # eliminate extra spaces in diff results, this is a bit risky,
        # could also simplify being that expect column is always on
        # the left so really are looking for actual_width being much
        # larger than expect_width.
        if ((actual_width - expect_width > 10)); then
            extra_space_width=$((actual_width-expect_width))
            extra_space_width=$((extra_space_width-5))
            debug "Eliminating $extra_space_width spaces from result file"
            sed -i -E "s/[ ]{$extra_space_width}/ /" $result_file
        fi

        fail_files+=("${result_file}")
        status="FAIL -> results in file '$result_file'"
        debug "Killing child process"
        kill -KILL $pid &> /dev/null
    fi

    comments=""                                     # clear comments for next session
    return 0;
}


################################################################################
# BEGIN main processing

if [[ "$#" < 1 ]]; then                             # check for presence of at least 1 argument
    printf "usage: testy <testspec> [testnum]\n"
    printf "       testy --help\n"
    exit 1
fi

# Command line argument processing
specfile=$1                                         # gather test file
debug "Testing $specfile"

if [[ "$specfile" = "--help" ]]; then               # check for --help option
    printf "$usage\n"
    exit 0
fi

shift
alltests="$@"                                       # remaining args are tests to run

##################################################
# first loop: read whole file into testdata array which will contain
# the text of each test. Record ONLY the start/end lines of each test
# to be used later.  Other side effects: evaluate any global #+TESTY:
# expressions, calculate the widest test title width for nice display
# later.
eval_testy_expr=1                                   # set to 0 after getting into the first test
test_beg_line=(-1)
test_end_line=(-1)
testnum=0                                           # current test number
linenum=0
while read -r; do                                     # read from test file, -r to prevent \-escaped chars
    updateline
    debug "$linenum: $line\n"
    case "$prefix" in
        "*")
            debug "^^ Test Start"
            eval_test_expr=0                        # in a test, wait to evaluate #+TESTY: expr until during test
            if (( testnum > 0 )); then                # if not the first test
                endline=$(( linenum-1 ))
                test_end_line+=("$endline")
                beg=${test_beg_line[testnum]}
                end=${test_end_line[testnum]}
                debug "Test $testnum beg $beg end $end"
            fi
            ((testnum++))                           # reset and start collecting text for the new test
            test_beg_line+=("$linenum")
            if (( ${#suffix} > $test_title_width )); then # calculate maximum width of any title
                test_title_width=${#suffix}
            fi
            ;;
        "#+TESTY:")                                # evaluate global expressions
            if [[ "$eval_testy_expr" = "1" ]]; then
                debug "Evaluating '$suffix'"
                eval "$suffix"
            fi
            testtext="$testtext\n$line"             # append line to current test text as it may be a local test option
            ;;
        "#+TITLE:")
            global_title="$suffix"
            debug "^^ setting global_title"
            ;;
        "#+title:")
            global_title="$suffix"
            debug "^^ setting global_title"
            ;;
        *)
            debug "^^ Ignoring line in first pass"
            ;;
    esac
done < $specfile

endline=$(( linenum ))                            # append the last test end
test_end_line+=("$endline")
beg=${test_beg_line[testnum]}
end=${test_end_line[testnum]}
debug "Test $testnum beg $beg end $end"

totaltests=$testnum                                 # set the total number of tests read from the file

# Debug output
for i in $(seq $testnum); do
    debug "-----TEST $i: beg ${test_beg_line[i]} end: ${test_end_line[i]} -----"
    while read -r; do                                # iterate over all lines of test
        debug ":TEST $i: $REPLY"
    done <<< "$(sed -n "${test_beg_line[i]},${test_end_line[i]}p" $specfile)"
done

##################################################
# Second loop: run tests


if [[ -z "$alltests" ]]; then                       # no individual tests specified on the command line
    alltests=$(seq $totaltests)                     # so run all tests
fi
ntests=$(wc -w <<< "$alltests")                     # count how many tests will be run
testcount=0
failcount=0

# Print header info 
printf "============================================================\n"
if [[ "$global_title" = "" ]]; then
    printf "== testy $specfile\n"
else
    printf "== testy $specfile : %s\n" "$global_title"
fi    
printf "== Running %d / %d tests\n" "$ntests" "$totaltests"

for testnum in $alltests; do                        # Iterate over all tests to be run
    ((testcount++))                                 # increment # of tests attempted
    reset_options
    comments=""                                     # initialize comments
    linenum=$((test_beg_line[testnum]-1))
    debug ":TEST $testnum: START at line $linenum"

    while read -r; do                                  # iterate over all lines of test
        updateline
        debug "$linenum: $line"

        case "$prefix" in
            "*")                                    # usually first line with title of the test
                test_title="$suffix"
                debug "test_title: $test_title"
                ;;
            "#+TESTY:")                             # eval some code to set options
                debug "evaluating '$suffix'"
                eval "$suffix"
                ;;
            "#+BEGIN_SRC")                          # test session starting
                debug ":TEST $testnum: Begin testing session"
                run_test_session
                if [[ "$status" != "pass" ]]; then
                    ((failcount++))                 # test failed, bail out of this test
                    break
                fi
                ;;
            "#+TESTY_RERUN:")                       # eval some code to set options
                old_linenum=$linenum
                beg=$((session_beg_line))           # #+BEGIN_SRC line
                end=$((session_end_line+1))         # #+END_SRC line
                linenum=$((beg-1))
                debug "^^ Re-running session on lines $beg to $end"
                # debug "sed -n '${beg},${end}p' $specfile"
                run_test_session <<< "$(sed -n "${beg},${end}p" $specfile)"
                debug "Done re-running session on lines $beg to $end"
                ;;
            *)                                      # any other lines are comments associated with a session
                if [[ "$comments" != "" ]] || [[ "$line" != "" ]]; then
                    debug "comment"                 # ignore leading blank lines in comments
                    comments="${comments}${line}\n"
                fi
                ;;
        esac
    done <<< "$(sed -n "${test_beg_line[testnum]},${test_end_line[testnum]}p" $specfile)"


    # report the final status of this test
    printf "%-3s %-${test_title_width}s : %s\n" "${testnum})" "$test_title" "$status"
done    

# Final Output
passcount=$((testcount-failcount))                  # calculate number of tests passed
printf "============================================================\n"
echo "RESULTS: $passcount / $testcount tests passed"

debug "SHOW: $SHOW"
if [[ "$SHOW" = "1" ]]; then                        # show failure results if requested
    printf "\n\nFAILURE RESULTS\n"
    printf "%s\n" "----------------------------------------"
    for f in "${fail_files[@]}"; do
        cat $f
        printf "%s\n" "----------------------------------------"
    done
fi
