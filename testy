#!/bin/bash
#
# parse the test file into an array of text for each test first before
# commencing with other processing

#DEBUG=
# IFS=''

STDBUF="stdbuf -i 0 -o 0 -e 0"                      # disables standard IO buffering for a program
SDIFF="diff -bBy"                                   # side by side diff, need to work on how to set the columns dynamically
# SDIFF="diff -bBy -W $COLUMNS"                       # side by side diff, need to work on how to set the columns dynamically
DIFF="diff --unchanged-line-format='' \
           --old-line-format='EXPECT:%dn) %L' \
           --new-line-format='ACTUAL:%dn) %L'"      # diff which will show prepend EXPECT/ACTUAL to differing lines
# DIFF="diff -bB -W $COLUMNS"

DEFAULT_PROGRAM="bash"                              # program to run if no option is specified
DEFAULT_PROMPT=">"                                  # prompt to honor if none is specified
DEFAULT_ECHOS_INPUT="0"                             # 0 for program NOT echoing input, insert it
DEFAULT_TAG="testy"

testdir="test-results"
title_width=20                                      # initial width for test titles, set to widest during initial parsing

function reset_options(){                           # reset options to defaults, run before each test session
    program=$DEFAULT_PROGRAM
    prompt=$DEFAULT_PROMPT
    echos_input=$DEFAULT_ECHOS_INPUT
    tag=$DEFAULT_TAG
}    


function debug(){                                   # print a debug message
    if [[ ! -z "$DEBUG" ]]; then
        echo "==DBG== $1"
    fi
}

function updateline(){                              # processes $line to set some other global variables
    line="$REPLY"                                   # copy from REPLY to avoid losing whitespace
    ((linenum++))                                   # update the current line number 
    prefix="${line%% *}"                            # extracts the first word on the line as prefix
    suffix="${line#* }"                             # extracts remainder of line
}    

################################################################################
# Run a Test Session
#
# Sets up a test session which is denoted by the #+BEGIN_SRC/#+END_SRC
# tags in the input file. Will set the 'status' variable before exiting to indicate whether 
function run_test_session(){
    toprog_fifo=$(mktemp --tmpdir testy_to.XXXXXX)  # set up communication with the program being tested
    fromprog_fifo=$(mktemp --tmpdir testy_from.XXXXXX)
    debug "toprog_fifo: $toprog_fifo"
    debug "fromprog_fifo: $fromprog_fifo"
    rm -f ${toprog_fifo} ${fromprog_fifo}           # remove just in case

    mkfifo $toprog_fifo                             # create the fifos
    mkfifo $fromprog_fifo

    debug "to fd: $to"
    debug "from fd: $from"

    debug "starting '$program <${toprog_fifo} >${fromprog_fifo} &'"

    # $program <${toprog_fifo} >${fromprog_fifo} &
    $STDBUF $program <${toprog_fifo} >${fromprog_fifo} &
    pid=$!
    debug "child pid: $pid"

    exec {to}>${toprog_fifo}                        # open connection to fifo for writing
    exec {from}<${fromprog_fifo}                    # and for reading

    status="pass"                                   # initial status, change to 'FAIL' if things go wrong
    expect=""                                       # expected output from test file
    actual=""                                       # actual output read from program
    # expect="==== EXPECT ===="                       # expected output from test file
    # actual="==== ACTUAL ===="                       # actual output read from program

    # MAIN LOOP to read lines of input, feed program, check output
    while read; do                                  
        updateline
        debug "$linenum: $line"
        
        if [[ "$prefix" == "#+END_SRC" ]]; then     # end of test, break out
            debug "$line: End Testing Session"
            break
        elif [[ "$prefix" = "$prompt" ]]; then      # test input, feed to program
            expect="${expect}${line}\n"                 # append input to expected
            input="$suffix"
            debug "Sending input: '$suffix'"
            printf "$input\n" >&$to                # send input after prompt to program
            if [[ "$echos_input" = "0" ]]; then     
                debug "no echo, appending '$line'"  # no echoing
                actual="${actual}${line}\n"             # append prompt+input to actual to simulate typing
            else
                debug "echos input, reading echo"   # program DOES echo 
                if ! read -t 0.5 0<&$from; then     # read prompt and typed input from program
                    debug "TIMED OUT on read (echoed input)"
                fi
                actual="${actual}${REPLY}\n"            # reply contains both prompt and echoed input
            fi

        else                                        # test output
            debug "Expect: $line"
            expect="${expect}${line}\n"
            if ! read -t 0.5 0<&$from; then
                debug "TIMED OUT on read"
            fi
            
            response=$REPLY
            debug "Actual: $response"
            actual="${actual}${response}\n"

        fi                                              # DONE with test input, either pass or fail
    done;

    debug "closing fifo fds ${to} ${from}"
    exec {to}>&-                                    # closes to to fifo
    exec {from}>&-                                  # closes to from fifo

    mkdir -p $testdir
    actual_file=$(printf "%s/%s-%02d-actual.tmp" "$testdir" "$tag" "$testnum")
    expect_file=$(printf "%s/%s-%02d-expect.tmp" "$testdir" "$tag" "$testnum")
    result_file=$(printf "%s/%s-%02d-result.tmp" "$testdir" "$tag" "$testnum")

    printf "$actual\n" > ${actual_file}
    printf "$expect\n" > ${expect_file}
    actual_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' $actual_file)
    expect_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' $expect_file)
    total_width=$((actual_width + expect_width + 3))
    debug "actual_width $actual_width"
    debug "expect_width $expect_width"
    debug "total_width $total_width"
    
    diffcmd="$DIFF ${expect_file} ${actual_file}"
    diffresult=$(eval "$diffcmd")
    diffreturn="$?"
    debug "diffresult: $diffresult"
    debug "diffreturn: $diffreturn"
    if [[ "$diffreturn" != "0" ]]; then
        status="FAIL"
    fi

    if [[ "$status" = "pass" ]]; then                      # test failed
        debug "NORMAL cleanup"                          # normal finish
        debug "Checking child status with kill -0"
        kill -0 $pid  >& /dev/null
        debug "kill returned: $?"
    else
        debug "FAILURE cleanup"
        {  printf '(TEST %d) %s' "$testnum" "$title"
           printf "${comments}\n" 
           printf "FAILURE: Output Mismatch at lines marked\n"
           printf "\n%s\n" "---Side by Side Differences---"
           printf "Differing lines have a character like '|' in the middle\n"
           printf "%-${expect_width}s   %-${actual_width}s\n" "==== EXPECT ====" "==== ACTUAL ===="
           $SDIFF -t -W $total_width $expect_file $actual_file 
           printf "%s\n" "---Line Differences---"
           printf "%s\n" "$diffresult"
           # -t for no tabs, -W for width
        } &> ${result_file}

        status="FAIL -> results in file '$result_file'"
        debug "Killing child process"
        kill -KILL $pid &> /dev/null
    fi


    debug "waiting on finished child"
    wait $pid &> /dev/null
    debug "wait returned: $?"

    return 0;
}


################################################################################
# BEGIN main processing
if [[ "$#" < 1 ]]; then
    printf "usage: testy <testspec> [testnum]\n"
    exit 1
fi

specfile=$1                                         # gather test file
debug "Testing $specfile"
shift


##################################################
# first loop: read whole file into testdata array which will contain
# the text of each test
testdata=()                                         # array of test data
testline=()                                         # array of lines at which tests start
testnum=0                                           # current test number
linenum=0
while read; do                                      # read all tests in from the file first
    updateline
    case "$prefix" in
        "*")
            if ((testnum > 0)); then                # if not the first test
                testdata[$testnum]="$testtext"      # add to the array of tests
            fi
            ((testnum++))                           # reset and start collecting text for the new test
            testtext="$line"                        # testtext hold all the text for the current test
            testline[$testnum]="$linenum"
            if (( ${#suffix} > $title_width )); then
                title_width=${#suffix}
            fi
            ;;
        "#+TYOPTS:")                                # global options
            variable="${suffix%% *}"                # variable name is first word
            value="${suffix#* }"                    # value is remainder of line
            eval "$variable='$value'"
            debug "option set: $variable='$value'"
            testtext="$testtext\n$line"             # append line to current test text as it may be a local test option
            ;;
        *)
            testtext="$testtext\n$line"             # append line to current test text
            ;;
    esac
done < $specfile
testdata[$testnum]="$testtext"                      # add last test to array

for i in $(seq $testnum); do
    debug "-----TEST $i-----"
    debug "${testline[$i]}"                         # print entire test with line breaks escaped
    debug "${testdata[$i]}"                         # print entire test with line breaks escaped
    while read w; do                                # iterate over all lines of test
        debug ":TEST $i: $w"
    done <<< $(printf "${testdata[$i]}")            # printf needed to get line breaks back in 
done

totaltests=$testnum

##################################################
# second loop: run tests

#printf "%s\n" "${testline[@]}"
debug "================================="

# set the tests to run here if only a single or subset of tests is to be run
alltests=$(seq $totaltests)
testcount=0
failcount=0

ntests=$(wc -w <<< "$alltests")

printf "Running %d / %d tests\n" "$ntests" "$totaltests"

for testnum in $alltests; do
    ((testcount++))
    reset_options
    linenum=$((${testline[testnum]} -1))
    comments=""
    debug ":TEST $testnum: START at line $linenum"

    while read; do                             # iterate over all lines of test
        updateline
        debug "$linenum: $line"

        case "$prefix" in
            "*")
                title="$suffix"
                debug "title: $title"
                ;;
            "#+TYOPTS:")
                variable="${suffix%% *}"            # variable name is first word
                value="${suffix#* }"                # value is remainder of line
                eval "$variable='$value'"
                debug "option set: $variable='$value'"
                ;;
            "#+BEGIN_SRC")
                debug ":TEST $testnum: Begin testing session"
                run_test_session
                if [[ "$status" != "pass" ]]; then
                    ((failcount++))
                    break
                fi
                ;;
            *)
                debug "comment"
                comments="$comments\n$line"
                ;;
        esac
    done <<< $(printf "${testdata[$testnum]}")      # printf needed to get line breaks back in 
    printf "%-3s %-${title_width}s : %s\n" "${testnum})" "$title" "$status"
done    

passcount=$((testcount-failcount))
echo ""
echo "RESULTS: $passcount / $testcount tests passed"
