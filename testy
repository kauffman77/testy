#!/bin/bash
#
# parse the test file into an array of text for each test first before
# commencing with other processing

read -r -d '' usage <<EOF
usage: testy <testfile.org>
       testy --help

Run tests for a shell program specified in an org-like file and report
the results.

--- Behavior Variables ---
The following variables can be specified in test files via lines like
  #+TESTY: var value
They will change the behavior of how the test data is interpretted.

Global variables that are usually specified at the beginning of a test
file before any other tests.
PROGRAM "bash"         : program to run/test if no option is specified
PROMPT ">"             : prompt to honor if none is specified
ECHO_STYLE "none"      : {none, prompt, input, both} for program input echoing style
TAG "testy"            : prefix for output files
TESTDIR "test-results" : directory where the resutls will be written


Local variables that can be specified for a single test session in an
individual test.
program "bash"         : override PROGRAM for an individual test session
prompt ">"             : override PROMPT for an individual test session
echo_style "none"      : override ECHO_STYLE for an individual test session
tag "testy"            : override TAG for an individual test session
testdir "test-results" : override TESTDIR for an individual test session

--- Environment Variables ---
These variables can be changed either via a 
  #+TESTY: var value
line or via an environment variable during a program run as in
  > VAR=value testy testfile.org

They control other behaviors of the program
DEBUG=0           : controls debugging
dump_errors=0     : controls whether test error results are printed after completing all tests
EOF

if [[ "$1" = "--help" ]]; then
    echo "$usage"
    exit 1
fi

# some global options/programs
STDBUF="stdbuf -i 0 -o 0 -e 0"                      # disables standard IO buffering for a program
SDIFF="diff -bBy"                                   # side by side diff, need to work on how to set the columns dynamically
DIFF="diff --unchanged-line-format='' \
           --old-line-format='EXPECT:%dn) %L' \
           --new-line-format='ACTUAL:%dn) %L'"      # diff which will show prepend EXPECT/ACTUAL to differing lines

# default values for the program to be tested
PROGRAM="bash"                                      # program to run if no option is specified
PROMPT=">"                                          # prompt to honor if none is specified
ECHO_STYLE="none"                                   # {none, prompt, input, both} for program input echoing style
TAG="testy"                                         # prefix for the 
TESTDIR="test-results"                              # directory where the resutls will be written

# default values for where the results will be stored
title_width=20                                      # initial width for test titles, set to widest during initial parsing

function reset_options(){                           # reset options to defaults, run before each test session
    program=$PROGRAM
    prompt=$PROMPT
    echo_style=$ECHO_STYLE
    tag=$TAG
    testdir=$TESTDIR
}    


function debug(){                                   # print a debug message
    if [[ ! -z "$DEBUG" ]]; then
        echo "==DBG== $1"
    fi
}

function updateline(){                              # processes $line to set some other global variables
    line="$REPLY"                                   # copy from REPLY to avoid losing whitespace
    ((linenum++))                                   # update the current line number 
    prefix="${line%% *}"                            # extracts the first word on the line as prefix
    suffix="${line#* }"                             # extracts remainder of line
}    

################################################################################
# Run a Test Session
#
# Sets up a test session which is denoted by the #+BEGIN_SRC/#+END_SRC
# tags in the input file. Will set the 'status' variable before
# exiting to indicate whether the test passes or fails. Influenced by
# many of the run variables including
# - program
# - tag
# - prompt
# 
# The function is run in a context where 'read' will extract lines
# from the test session.
function run_test_session(){
    toprog_fifo=$(mktemp --tmpdir testy_to.XXXXXX)  # set up communication with the program being tested
    fromprog_fifo=$(mktemp --tmpdir testy_from.XXXXXX)
    debug "toprog_fifo: $toprog_fifo"
    debug "fromprog_fifo: $fromprog_fifo"
    rm -f ${toprog_fifo} ${fromprog_fifo}           # remove just in case

    mkfifo $toprog_fifo                             # create the fifos
    mkfifo $fromprog_fifo

    debug "to fd: $to"
    debug "from fd: $from"

    debug "starting '$program <${toprog_fifo} >${fromprog_fifo} &'"

    # run program under stdbuf to eliminate I/O buffering, I/O comes through fifos
    $STDBUF $program <${toprog_fifo} >${fromprog_fifo} & 
    pid=$!
    debug "child pid: $pid"

    # must open these after running the program or testy will stall 
    exec {to}>${toprog_fifo}                        # open connection to fifo for writing
    exec {from}<${fromprog_fifo}                    # and for reading

    status="pass"                                   # initial status, change to 'FAIL' if things go wrong
    expect=""                                       # expected output from test file
    actual=""                                       # actual output read from program
    # expect="==== EXPECT ===="                       # expected output from test file
    # actual="==== ACTUAL ===="                       # actual output read from program

    # MAIN LOOP to read lines of input, feed program, check output
    while read; do                                  # read a line from the test session
        updateline
        debug "$linenum: $line"
        
        case "$prefix" in
            "#+END_SRC")                            # end of test, break out
                debug "$line: End Testing Session"
                break
                ;;
            "$prompt")                                  # test input, feed to program
                expect+="${line}\n"                     # append input to expected
                input="$suffix"
                debug "Sending input: '$suffix'"
                printf "$input\n" >&$to                 # send input after prompt to program
                case "$echo_style" in
                    "none")                             # no echoing, append prompt+input to actual to simulate typing
                        debug "no echo, appending '$line'" 
                        actual+="${line}\n"
                        ;;
                    "prompt")
                        debug "echos prompt only"
                        if ! read -t 0.5 -d ' ' 0<&$from; then # read echoed prompt
                            actual+="testy: TIMED OUT reading echoed prompt\n"
                            break
                        else
                            actual+="$REPLY $input\n"
                        fi
                        ;;
                    "input")
                        debug "echos input only"
                        if ! read -t 0.5 0<&$from; then # read echoed input
                            actual+="testy: TIMED OUT reading echoed input\n"
                            break
                        else
                            actual+="$prompt $REPLY\n"
                        fi
                        ;;
                    "both")
                        if ! read -t 0.5 0<&$from; then # read echoed pompt+input
                            actual+="testy: TIMED OUT reading echoed prompt/input\n"
                            break
                        else
                            actual+="$REPLY\n"      # reply contains both prompt and echoed input

                        fi
                        ;;
                esac
                ;;
            *)                                        # other lines are test output
                debug "Expect: $line"
                expect="${expect}${line}\n"
                if ! read -t 0.5 0<&$from; then
                    actual+="testy: TIMED OUT reading program output\n"
                    debug "TIMED OUT on read"
                    break
                fi
                response=$REPLY
                debug "Actual: $response"
                actual="${actual}${response}\n"
                ;;
        esac                                          # DONE with test input, either pass or fail
    done;

    debug "closing fifo fds ${to} ${from}"
    exec {to}>&-                                    # closes to to fifo
    exec {from}>&-                                  # closes to from fifo

    mkdir -p $testdir
    actual_file=$(printf "%s/%s-%02d-actual.tmp" "$testdir" "$tag" "$testnum")
    expect_file=$(printf "%s/%s-%02d-expect.tmp" "$testdir" "$tag" "$testnum")
    result_file=$(printf "%s/%s-%02d-result.tmp" "$testdir" "$tag" "$testnum")

    printf "$actual\n" > ${actual_file}
    printf "$expect\n" > ${expect_file}
    actual_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' $actual_file)
    expect_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' $expect_file)
    total_width=$((actual_width + expect_width + 3))
    debug "actual_width $actual_width"
    debug "expect_width $expect_width"
    debug "total_width $total_width"
    
    diffcmd="$DIFF ${expect_file} ${actual_file}"
    diffresult=$(eval "$diffcmd")
    diffreturn="$?"
    debug "diffresult: $diffresult"
    debug "diffreturn: $diffreturn"
    if [[ "$diffreturn" != "0" ]]; then
        status="FAIL"
    fi

    if [[ "$status" = "pass" ]]; then                      # test failed
        debug "NORMAL cleanup"                          # normal finish
        debug "Checking child status with kill -0"
        kill -0 $pid  >& /dev/null
        debug "kill returned: $?"
    else
        debug "FAILURE cleanup"
        {  printf '(TEST %d) %s' "$testnum" "$title"
           printf "${comments}\n" 
           printf "FAILURE: Output Mismatch at lines marked\n"
           printf "\n%s\n" "---Side by Side Differences---"
           printf "Differing lines have a character like '|' in the middle\n"
           printf "%-${expect_width}s   %-${actual_width}s\n" "==== EXPECT ====" "==== ACTUAL ===="
           $SDIFF -t -W $total_width $expect_file $actual_file 
           printf "%s\n" "---Line Differences---"
           printf "%s\n" "$diffresult"
           # -t for no tabs, -W for width
        } &> ${result_file}

        fail_files+="${result_file}"
        status="FAIL -> results in file '$result_file'"
        debug "Killing child process"
        kill -KILL $pid &> /dev/null
    fi


    debug "waiting on finished child"
    wait $pid &> /dev/null
    debug "wait returned: $?"

    return 0;
}


################################################################################
# BEGIN main processing
if [[ "$#" < 1 ]]; then
    printf "usage: testy <testspec> [testnum]\n"
    exit 1
fi

specfile=$1                                         # gather test file
debug "Testing $specfile"
shift


##################################################
# first loop: read whole file into testdata array which will contain
# the text of each test
testdata=()                                         # array of test data
testline=()                                         # array of lines at which tests start
testnum=0                                           # current test number
linenum=0
while read; do                                      # read all tests in from the file first
    updateline
    case "$prefix" in
        "*")
            if ((testnum > 0)); then                # if not the first test
                testdata[$testnum]="$testtext"      # add to the array of tests
            fi
            ((testnum++))                           # reset and start collecting text for the new test
            testtext="$line"                        # testtext hold all the text for the current test
            testline[$testnum]="$linenum"
            if (( ${#suffix} > $title_width )); then
                title_width=${#suffix}
            fi
            ;;
        "#+TESTY:")                                # global options
            variable="${suffix%% *}"                # variable name is first word
            value="${suffix#* }"                    # value is remainder of line
            eval "$variable='$value'"
            debug "option set: $variable='$value'"
            testtext="$testtext\n$line"             # append line to current test text as it may be a local test option
            ;;
        *)
            testtext="$testtext\n$line"             # append line to current test text
            ;;
    esac
done < $specfile
testdata[$testnum]="$testtext"                      # add last test to array

for i in $(seq $testnum); do
    debug "-----TEST $i-----"
    debug "${testline[$i]}"                         # print entire test with line breaks escaped
    debug "${testdata[$i]}"                         # print entire test with line breaks escaped
    while read w; do                                # iterate over all lines of test
        debug ":TEST $i: $w"
    done <<< $(printf "${testdata[$i]}")            # printf needed to get line breaks back in 
done

totaltests=$testnum

##################################################
# second loop: run tests

#printf "%s\n" "${testline[@]}"
debug "================================="

# set the tests to run here if only a single or subset of tests is to be run
alltests=$(seq $totaltests)
testcount=0
failcount=0

ntests=$(wc -w <<< "$alltests")

printf "Running %d / %d tests\n" "$ntests" "$totaltests"

for testnum in $alltests; do
    ((testcount++))
    reset_options
    linenum=$((${testline[testnum]} -1))
    comments=""
    debug ":TEST $testnum: START at line $linenum"

    while read; do                             # iterate over all lines of test
        updateline
        debug "$linenum: $line"

        case "$prefix" in
            "*")
                title="$suffix"
                debug "title: $title"
                ;;
            "#+TESTY:")
                variable="${suffix%% *}"            # variable name is first word
                value="${suffix#* }"                # value is remainder of line
                eval "$variable='$value'"
                debug "option set: $variable='$value'"
                ;;
            "#+BEGIN_SRC")
                debug ":TEST $testnum: Begin testing session"
                run_test_session
                if [[ "$status" != "pass" ]]; then
                    ((failcount++))
                    break
                fi
                ;;
            *)
                debug "comment"
                comments="$comments\n$line"
                ;;
        esac
    done <<< $(printf "${testdata[$testnum]}")      # printf needed to get line breaks back in 
    printf "%-3s %-${title_width}s : %s\n" "${testnum})" "$title" "$status"
done    

passcount=$((testcount-failcount))
echo ""
echo "RESULTS: $passcount / $testcount tests passed"

debug "dump_errors: $dump_errors"

if [[ "$dump_errors" = "1" ]]; then
    printf "\n\nFAILURE RESULTS\n"
    printf "%s\n" "----------------------------------------"
    for f in $fail_files; do
        cat $f
        printf "%s\n" "----------------------------------------"
    done
fi
